<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Play Tetris</title>
    <link rel="stylesheet" href="tetris.css">
</head>
<body>
    <header>
        <h1>Web Play Tetris</h1>
        <div class="button-container">
            <button id="start-button">게임 시작</button>
            <button id="pause-button" disabled>일시정지</button>
        </div>
    </header>
    
    <div class="game-container">
        <canvas id="game-board" width="240" height="400"></canvas>
        
        <div class="side-panel">
            <div class="panel-box">
                <div class="panel-title">다음 블록</div>
                <canvas id="next-piece" width="100" height="100"></canvas>
            </div>
            
            <div class="panel-box">
                <div class="panel-title">점수</div>
                <div id="score" class="panel-value">0</div>
            </div>
            
            <div class="panel-box">
                <div class="panel-title">레벨</div>
                <div id="level" class="panel-value">1</div>
            </div>
            
            <div class="panel-box">
                <div class="panel-title">라인</div>
                <div id="lines" class="panel-value">0</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <div class="controls-title">게임 조작</div>
        <div class="key-container">
            <div class="key-group">
                <span class="key">←</span>
                <span class="key-action">왼쪽 이동</span>
            </div>
            <div class="key-group">
                <span class="key">→</span>
                <span class="key-action">오른쪽 이동</span>
            </div>
            <div class="key-group">
                <span class="key">↑</span>
                <span class="key-action">회전</span>
            </div>
            <div class="key-group">
                <span class="key">↓</span>
                <span class="key-action">빠르게 내리기</span>
            </div>
            <div class="key-group">
                <span class="key">Space</span>
                <span class="key-action">즉시 떨어뜨리기</span>
            </div>
        </div>
    </div>
    
    <script>
        // 게임 변수
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece');
        const nextCtx = nextCanvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        
        // 게임 설정
        const ROWS = 20;
        const COLUMNS = 12;
        const BLOCK_SIZE = 20;
        const EMPTY = "#16213e";
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameInterval;
        let isPaused = false;
        let gameOver = true;
        let currentSpeed = 1000;
        
        // 테트리스 조각 색상 (더 화려한 색상)
        const COLORS = [
            null,
            '#FF1E56', // I - 밝은 빨강
            '#00DDFF', // J - 밝은 파랑
            '#22EAAA', // L - 밝은 민트
            '#FFCC00', // O - 밝은 노랑
            '#FF8700', // S - 밝은 주황
            '#A761FF', // T - 밝은 보라
            '#00CCDD'  // Z - 밝은 청록
        ];
        
        // 테트리스 조각 형태
        const SHAPES = [
            null,
            // I
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            // J
            [
                [2, 0, 0],
                [2, 2, 2],
                [0, 0, 0]
            ],
            // L
            [
                [0, 0, 3],
                [3, 3, 3],
                [0, 0, 0]
            ],
            // O
            [
                [4, 4],
                [4, 4]
            ],
            // S
            [
                [0, 5, 5],
                [5, 5, 0],
                [0, 0, 0]
            ],
            // T
            [
                [0, 6, 0],
                [6, 6, 6],
                [0, 0, 0]
            ],
            // Z
            [
                [7, 7, 0],
                [0, 7, 7],
                [0, 0, 0]
            ]
        ];
        
        // 게임 보드 생성
        let board = Array.from({ length: ROWS }, () => Array(COLUMNS).fill(0));
        
        // 현재 및 다음 조각
        let currentPiece = null;
        let nextPiece = null;
        
        // 조각 정보 저장 객체
        class Piece {
            constructor(shape, color) {
                this.shape = shape;
                this.color = color;
                this.y = 0;
                this.x = Math.floor(COLUMNS / 2) - Math.floor(shape[0].length / 2);
                this.rotation = 0;
            }
        }
        
        // 새 조각 생성
        function createPiece() {
            const randomIndex = Math.floor(Math.random() * 7) + 1;
            return new Piece(SHAPES[randomIndex], COLORS[randomIndex]);
        }
        
        // 게임 초기화
        function initGame() {
            board = Array.from({ length: ROWS }, () => Array(COLUMNS).fill(0));
            score = 0;
            level = 1;
            lines = 0;
            gameOver = false;
            currentSpeed = 1000;
            
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
            
            currentPiece = createPiece();
            nextPiece = createPiece();
            
            drawBoard();
            drawPiece();
            drawNextPiece();
            
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(moveDown, currentSpeed);
        }
        
        // 보드 그리기
        function drawBoard() {
            ctx.fillStyle = EMPTY;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLUMNS; x++) {
                    if (board[y][x] !== 0) {
                        drawBlock(ctx, x, y, COLORS[board[y][x]]);
                    }
                }
            }
            
            // 그리드 라인 (더 투명하게)
            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 0.5;
            
            // 수직선
            for (let x = 0; x <= COLUMNS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // 수평선
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(COLUMNS * BLOCK_SIZE, y * BLOCK_SIZE);
                ctx.stroke();
            }
        }
        
        // 조각 그리기
        function drawPiece() {
            const shape = currentPiece.shape;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x] !== 0) {
                        drawBlock(ctx, currentPiece.x + x, currentPiece.y + y, currentPiece.color);
                    }
                }
            }
            
            // 그림자 조각 그리기
            let ghostY = currentPiece.y;
            while (true) {
                ghostY++;
                if (!isPieceValidPosition(currentPiece.x, ghostY, currentPiece.shape)) {
                    ghostY--;
                    break;
                }
            }
            
            // 현재 위치와 다를 때만 그림자 그리기
            if (ghostY !== currentPiece.y) {
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x] !== 0) {
                            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                            ctx.fillRect((currentPiece.x + x) * BLOCK_SIZE, (ghostY + y) * BLOCK_SIZE, 
                                BLOCK_SIZE, BLOCK_SIZE);
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                            ctx.strokeRect((currentPiece.x + x) * BLOCK_SIZE, (ghostY + y) * BLOCK_SIZE, 
                                BLOCK_SIZE, BLOCK_SIZE);
                        }
                    }
                }
            }
        }
        
        // 다음 조각 그리기
        function drawNextPiece() {
            nextCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            const shape = nextPiece.shape;
            const blockSize = 20;
            const offsetX = (nextCanvas.width - shape[0].length * blockSize) / 2;
            const offsetY = (nextCanvas.height - shape.length * blockSize) / 2;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x] !== 0) {
                        nextCtx.fillStyle = nextPiece.color;
                        nextCtx.fillRect(offsetX + x * blockSize, offsetY + y * blockSize, 
                            blockSize - 1, blockSize - 1);
                        
                        // 블록에 하이라이트 효과 추가
                        nextCtx.fillStyle = "rgba(255, 255, 255, 0.3)";
                        nextCtx.fillRect(offsetX + x * blockSize, offsetY + y * blockSize, 
                            blockSize - 1, blockSize / 3);
                    }
                }
            }
        }
        
        // 블록 그리기 - 약간의 그라데이션 효과 추가
        function drawBlock(context, x, y, color) {
            const xPos = x * BLOCK_SIZE;
            const yPos = y * BLOCK_SIZE;
            
            // 메인 블록
            context.fillStyle = color;
            context.fillRect(xPos, yPos, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            
            // 하이라이트 효과 (위쪽에 밝은 부분)
            context.fillStyle = "rgba(255, 255, 255, 0.3)";
            context.fillRect(xPos, yPos, BLOCK_SIZE - 1, BLOCK_SIZE / 3);
        }
        
        // 위치가 유효한지 확인
        function isPieceValidPosition(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] !== 0) {
                        let newX = x + col;
                        let newY = y + row;
                        
                        if (newX < 0 || newX >= COLUMNS || newY >= ROWS) {
                            return false;
                        }
                        
                        if (newY >= 0 && board[newY][newX] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        // 조각 회전
        function rotate() {
            const rotated = [];
            const shape = currentPiece.shape;
            
            for (let y = 0; y < shape[0].length; y++) {
                rotated.push([]);
                for (let x = 0; x < shape.length; x++) {
                    rotated[y].push(shape[shape.length - 1 - x][y]);
                }
            }
            
            if (isPieceValidPosition(currentPiece.x, currentPiece.y, rotated)) {
                currentPiece.shape = rotated;
                drawBoard();
                drawPiece();
            }
        }
        
        // 조각 아래로 이동
        function moveDown() {
            if (isPieceValidPosition(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                currentPiece.y++;
                drawBoard();
                drawPiece();
            } else {
                lockPiece();
            }
        }
        
        // 조각을 보드에 고정
        function lockPiece() {
            const shape = currentPiece.shape;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x] !== 0) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        
                        // 맨 위에 도달하면 게임 오버
                        if (boardY <= 0) {
                            gameOver = true;
                            clearInterval(gameInterval);
                            
                            // 게임 오버 애니메이션 (보드를 점차 어둡게)
                            let opacity = 0;
                            let gameOverInterval = setInterval(() => {
                                opacity += 0.05;
                                if (opacity >= 0.8) {
                                    clearInterval(gameOverInterval);
                                    alert('게임 오버! 점수: ' + score);
                                    startButton.disabled = false;
                                    pauseButton.disabled = true;
                                }
                                
                                ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                            }, 50);
                            
                            return;
                        }
                        
                        board[boardY][boardX] = shape[y][x];
                    }
                }
            }
            
            clearLines();
            
            if (!gameOver) {
                currentPiece = nextPiece;
                nextPiece = createPiece();
                drawNextPiece();
                
                // 새 조각이 바로 충돌한다면 게임 오버
                if (!isPieceValidPosition(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                    gameOver = true;
                    clearInterval(gameInterval);
                    
                    // 게임 오버 애니메이션
                    let opacity = 0;
                    let gameOverInterval = setInterval(() => {
                        opacity += 0.05;
                        if (opacity >= 0.8) {
                            clearInterval(gameOverInterval);
                            alert('게임 오버! 점수: ' + score);
                            startButton.disabled = false;
                            pauseButton.disabled = true;
                        }
                        
                        ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }, 50);
                }
            }
            
            drawBoard();
            drawPiece();
        }
        
        // 줄 지우기
        function clearLines() {
            let linesCleared = 0;
            let linesToClear = [];
            
            for (let y = ROWS - 1; y >= 0; y--) {
                let isLineComplete = true;
                
                for (let x = 0; x < COLUMNS; x++) {
                    if (board[y][x] === 0) {
                        isLineComplete = false;
                        break;
                    }
                }
                
                if (isLineComplete) {
                    linesToClear.push(y);
                    linesCleared++;
                }
            }
            
            // 라인 지우기 애니메이션 효과
            if (linesToClear.length > 0) {
                let flashCount = 0;
                let flashInterval = setInterval(() => {
                    flashCount++;
                    
                    // 라인 깜빡임 효과
                    for (let i = 0; i < linesToClear.length; i++) {
                        const lineY = linesToClear[i];
                        for (let x = 0; x < COLUMNS; x++) {
                            if (flashCount % 2 === 0) {
                                board[lineY][x] = 0; // 비우기
                            } else {
                                board[lineY][x] = 1; // 채우기 (색상은 중요하지 않음)
                            }
                        }
                    }
                    
                    drawBoard();
                    drawPiece();
                    
                    if (flashCount >= 4) {
                        clearInterval(flashInterval);
                        
                        // 실제로 라인 제거하기
                        for (let i = 0; i < linesToClear.length; i++) {
                            const lineY = linesToClear[i];
                            // 해당 줄 지우기 (위에서 아래로 복사)
                            for (let y = lineY; y > 0; y--) {
                                for (let x = 0; x < COLUMNS; x++) {
                                    board[y][x] = board[y - 1][x];
                                }
                            }
                            // 가장 위 줄은 0으로 채우기
                            for (let x = 0; x < COLUMNS; x++) {
                                board[0][x] = 0;
                            }
                            
                            // 다음 처리할 라인의 인덱스 조정 (라인이 내려왔으므로)
                            for (let j = i + 1; j < linesToClear.length; j++) {
                                linesToClear[j]++;
                            }
                        }
                        
                        // 점수 업데이트
                        updateScore(linesCleared);
                        
                        drawBoard();
                        drawPiece();
                    }
                }, 100);
            }
        }
        
        // 점수 업데이트
        function updateScore(linesCleared) {
            // 점수 계산: 1줄=100, 2줄=300, 3줄=500, 4줄=800
            const points = [0, 100, 300, 500, 800];
            const oldScore = score;
            score += points[linesCleared] * level;
            lines += linesCleared;
            
            // 숫자 증가 애니메이션
            const scoreIncrement = Math.ceil((score - oldScore) / 10);
            let animatedScore = oldScore;
            
            const scoreInterval = setInterval(() => {
                animatedScore += scoreIncrement;
                if (animatedScore >= score) {
                    animatedScore = score;
                    clearInterval(scoreInterval);
                }
                scoreElement.textContent = animatedScore;
            }, 50);
            
            linesElement.textContent = lines;
            
            // 10줄마다 레벨 업
            if (Math.floor(lines / 10) >= level) {
                level++;
                levelElement.textContent = level;
                
                // 레벨 업 시각 효과
                levelElement.style.transform = "scale(1.2)";
                levelElement.style.color = "#FFCC00";
                
                setTimeout(() => {
                    levelElement.style.transform = "scale(1)";
                    levelElement.style.color = "";
                }, 300);
                
                // 속도 증가
                currentSpeed = Math.max(100, 1000 - (level - 1) * 100);
                clearInterval(gameInterval);
                gameInterval = setInterval(moveDown, currentSpeed);
            }
        }
        
        // 조각 좌우 이동
        function moveSideways(direction) {
            if (isPieceValidPosition(currentPiece.x + direction, currentPiece.y, currentPiece.shape)) {
                currentPiece.x += direction;
                drawBoard();
                drawPiece();
            }
        }
        
        // 조각 빠르게 떨어뜨리기
        function hardDrop() {
            let dropDistance = 0;
            while (isPieceValidPosition(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                currentPiece.y++;
                dropDistance++;
            }
            
            // 하드 드롭 보너스 점수
            if (dropDistance > 0) {
                score += dropDistance;
                scoreElement.textContent = score;
            }
            
            lockPiece();
        }
        
        // 키보드 이벤트 처리
        document.addEventListener('keydown', function(e) {
            if (gameOver || isPaused) return;
            
            switch (e.keyCode) {
                case 37: // 왼쪽 화살표
                    moveSideways(-1);
                    break;
                case 39: // 오른쪽 화살표
                    moveSideways(1);
                    break;
                case 40: // 아래 화살표
                    moveDown();
                    break;
                case 38: // 위 화살표
                    rotate();
                    break;
                case 32: // 스페이스바
                    hardDrop();
                    break;
            }
        });
        
        // 게임 시작 버튼
        startButton.addEventListener('click', function() {
            initGame();
            startButton.disabled = true;
            pauseButton.disabled = false;
        });
        
        // 일시정지 버튼
        pauseButton.addEventListener('click', function() {
            if (isPaused) {
                gameInterval = setInterval(moveDown, currentSpeed);
                pauseButton.textContent = '일시정지';
            } else {
                clearInterval(gameInterval);
                pauseButton.textContent = '계속하기';
                
                // 일시정지 화면
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.font = "20px Poppins";
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.fillText("일시정지", canvas.width / 2, canvas.height / 2);
            }
            
            isPaused = !isPaused;
        });
        
        // 게임 보드 초기 그리기
        drawBoard();
    </script>
</body>
</html>